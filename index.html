<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tree DP & Graph Editor</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&family=Space+Grotesk:wght@400;500;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #0a0a0f; --bg-elevated: #12121a; --card: #1a1a24; --border: #2a2a3a;
      --fg: #e8e8f0; --muted: #6a6a7a; --accent: #00d4aa; --accent-dim: rgba(0, 212, 170, 0.15);
      --danger: #ff4466; --purple: #bd93f9; --orange: #ffb86c;
    }
    * { box-sizing: border-box; }
    body { font-family: 'Space Grotesk', sans-serif; background: var(--bg); color: var(--fg); min-height: 100vh; margin: 0; }
    .mono { font-family: 'JetBrains Mono', monospace; }
    .bg-grid {
      background-image: linear-gradient(rgba(42, 42, 58, 0.3) 1px, transparent 1px),
                        linear-gradient(90deg, rgba(42, 42, 58, 0.3) 1px, transparent 1px);
      background-size: 20px 20px;
    }
    .btn { transition: all 0.15s ease; border: none; outline: none; cursor: pointer; }
    .btn:hover:not(:disabled) { transform: translateY(-1px); filter: brightness(1.1); }
    .mode-btn { border: 1px solid var(--border); background: var(--card); }
    .mode-btn.active { border-color: var(--accent); background: var(--accent-dim); color: var(--accent); }

    .toggle-container { display: flex; align-items: center; gap: 6px; user-select: none; cursor: pointer; font-size: 11px; }
    .toggle-switch { position: relative; width: 32px; height: 18px; background: var(--border); border-radius: 10px; transition: background 0.2s; flex-shrink: 0;}
    .toggle-switch.active { background: var(--accent); }
    .toggle-switch::after { content: ''; position: absolute; top: 2px; left: 2px; width: 14px; height: 14px; background: var(--fg); border-radius: 50%; transition: transform 0.2s; }
    .toggle-switch.active::after { transform: translateX(14px); }

    .canvas-container { position: relative; border: 1px solid var(--border); border-radius: 12px; overflow: hidden; background: var(--bg-elevated); }
    #graphCanvas { display: block; }
    #graphCanvas.mode-add { cursor: crosshair; }
    #graphCanvas.mode-select { cursor: default; }
    #graphCanvas.mode-connect { cursor: cell; }

    .output-panel { background: var(--bg-elevated); border: 1px solid var(--border); border-radius: 12px; }
    .output-header { border-bottom: 1px solid var(--border); padding: 8px 12px; }
    .output-content { max-height: 450px; overflow-y: auto; }

    input, textarea, select { background: var(--bg); border: 1px solid var(--border); color: var(--fg); border-radius: 6px; padding: 6px 10px; font-family: 'JetBrains Mono', monospace; font-size: 12px; }
    input:focus, textarea:focus, select:focus { outline: none; border-color: var(--accent); }
    select { cursor: pointer; }
    select option { background: var(--card); color: var(--fg); }

    .tab-btn { padding: 8px 16px; font-size: 12px; border-bottom: 2px solid transparent; color: var(--muted); cursor: pointer; background: none; border-top: none; border-left: none; border-right: none; }
    .tab-btn.active { color: var(--accent); border-bottom-color: var(--accent); }
    table { width: 100%; border-collapse: collapse; font-size: 11px; }
    th, td { padding: 4px 8px; text-align: left; border-bottom: 1px solid var(--border); }

    .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 50; opacity: 0; pointer-events: none; transition: opacity 0.2s; }
    .modal-overlay.active { opacity: 1; pointer-events: all; }
    .modal { background: var(--card); border: 1px solid var(--border); border-radius: 12px; padding: 16px; width: 90%; max-width: 500px; box-shadow: 0 10px 40px rgba(0,0,0,0.5); }

    .cb-container { display: flex; align-items: center; gap: 6px; cursor: pointer; user-select: none; font-size: 11px; }
    .cb-container input { display: none; }
    .cb-box { width: 16px; height: 16px; border: 1px solid var(--border); border-radius: 4px; background: var(--bg); display: flex; align-items: center; justify-content: center; transition: all 0.1s; }
    .cb-container input:checked + .cb-box { background: var(--accent); border-color: var(--accent); }
    .cb-box::after { content: '‚úì'; color: var(--bg); font-size: 10px; opacity: 0; }
    .cb-container input:checked + .cb-box::after { opacity: 1; }

    .error-box { background: rgba(255, 68, 102, 0.1); border: 1px solid rgba(255, 68, 102, 0.3); color: #ff8a9e; padding: 8px 12px; border-radius: 6px; font-size: 11px; margin-bottom: 8px; font-family: 'JetBrains Mono'; white-space: pre-wrap; }

    .doc-code { background: var(--bg); border: 1px solid var(--border); padding: 2px 5px; border-radius: 4px; color: var(--purple); font-family: 'JetBrains Mono', monospace; font-size: 11px; }
    .doc-section { margin-bottom: 12px; }
    .doc-section-title { color: var(--accent); font-weight: 600; display: block; margin-bottom: 6px; font-size: 12px; }
    .doc-list { list-style: none; padding: 0; margin: 0; }
    .doc-list li { margin-bottom: 3px; color: #9ca3af; font-size: 11px; line-height: 1.5; }
  </style>
</head>
<body class="p-4 md:p-6">

  <div id="importModal" class="modal-overlay">
    <div class="modal">
      <h3 class="font-bold text-lg mb-2">Import / Reset</h3>
      <p class="text-xs mb-2" style="color:var(--muted)">Format: V E, then V weights, then E lines of edges (u v w).</p>
      <textarea id="importText" class="w-full" rows="6" placeholder="3 2&#10;1 2 3&#10;1 2 1&#10;2 3 1"></textarea>
      <div class="flex justify-end gap-2 mt-3">
        <button id="btnResetSave" class="btn px-3 py-1.5 rounded text-xs mr-auto" style="background: var(--danger); color: white;">Reset Save</button>
        <button id="btnModalClose" class="btn px-3 py-1.5 rounded text-xs" style="background:var(--border)">Cancel</button>
        <button id="btnModalImport" class="btn px-3 py-1.5 rounded text-xs" style="background:var(--accent); color:var(--bg)">Import</button>
      </div>
    </div>
  </div>

  <div class="max-w-7xl mx-auto">
    <header class="mb-4">
      <h1 class="text-2xl md:text-3xl font-bold tracking-tight">Graph <span style="color: var(--accent);">Editor</span> & DP</h1>
    </header>

    <div class="grid lg:grid-cols-3 gap-4">
      <div class="lg:col-span-2 space-y-3">
        <div class="p-3 rounded-lg flex flex-col gap-3" style="background: var(--card); border: 1px solid var(--border);">
          <div class="flex flex-wrap gap-2 items-center justify-between">
            <div class="flex gap-2">
              <button id="btnAdd" class="mode-btn btn px-3 py-1.5 rounded text-xs font-medium">Add (A)</button>
              <button id="btnConnect" class="mode-btn btn px-3 py-1.5 rounded text-xs font-medium">Connect (C)</button>
              <button id="btnSelect" class="mode-btn btn px-3 py-1.5 rounded text-xs font-medium">Edit (S)</button>
            </div>
            <div class="flex gap-2">
              <button id="btnUndo" class="btn text-xs px-2 py-1 rounded" style="background: var(--border); color: var(--fg);">Undo</button>
              <button id="btnRedo" class="btn text-xs px-2 py-1 rounded" style="background: var(--border); color: var(--fg);">Redo</button>
              <button id="btnOpenImport" class="btn text-xs px-2 py-1 rounded" style="background: var(--border); color: var(--fg);">Menu</button>
            </div>
          </div>
          <div class="flex flex-wrap gap-x-6 gap-y-2 items-center border-t pt-3" style="border-color: var(--border);">
            <div class="flex gap-4">
              <div id="tglTreeContainer" class="toggle-container"><div id="tglTree" class="toggle-switch active"></div><span>Tree</span></div>
              <div id="tglDirectedContainer" class="toggle-container"><div id="tglDirected" class="toggle-switch active"></div><span>Directed</span></div>
              <div id="tglShowEdgeWContainer" class="toggle-container"><div id="tglShowEdgeW" class="toggle-switch"></div><span>Edge W</span></div>
            </div>
          </div>
        </div>

        <div class="canvas-container bg-grid">
          <canvas id="graphCanvas"></canvas>
        </div>

        <div class="p-3 rounded-lg" style="background: var(--card); border: 1px solid var(--border);">
          <div class="text-xs font-semibold mb-2 opacity-70">Vertex Content</div>
          <div id="displayOptionsContainer" class="flex flex-wrap gap-3"></div>
        </div>

        <div class="p-3 rounded-lg" style="background: var(--card); border: 1px solid var(--border);">
          <div class="flex justify-between items-center mb-2">
            <div class="flex items-center gap-2">
              <h3 class="font-semibold text-sm">DP Formulas</h3>
              <select id="dpExamples" class="text-xs py-1 px-2" style="font-family: 'Space Grotesk', sans-serif;">
                <option value="">Examples...</option>
                <option value="subtree_size">Subtree Size</option>
                <option value="subtree_sum">Subtree Sum</option>
                <option value="max_independent">Max Independent Set</option>
                <option value="min_vertex_cover">Min Vertex Cover</option>
                <option value="tree_diameter">Tree Diameter</option>
                <option value="sum_of_distances">Sum of Distances (Rerooting)</option>
                <option value="tree_matching">Tree Matching</option>
                <option value="tree_coloring">Tree Coloring (k=3)</option>
                <option value="longest_edge_path">Longest Path (Edge W)</option>
              </select>
            </div>
            <div class="flex gap-2">
              <button id="btnSaveFormula" class="btn text-xs px-2 py-1 rounded font-medium" style="background: var(--border); color: var(--text);" title="Save current formula">üíæ</button>
              <button id="btnDeleteFormula" class="btn text-xs px-2 py-1 rounded font-medium" style="background: var(--border); color: var(--text);" title="Delete saved formula">üóëÔ∏è</button>
              <button id="btnRunDp" class="btn text-xs px-3 py-1 rounded font-medium" style="background: var(--accent); color: var(--bg);">Run (Ctrl+Enter)</button>
            </div>
          </div>
          <div id="dpErrorBox" class="error-box hidden"></div>
          <div id="dpWarning" class="hidden text-xs mb-2 p-2 rounded" style="background: rgba(255,170,0,0.2); color: var(--orange);">Warning: Tree Mode is disabled. DP requires a tree structure.</div>
          <textarea id="dpCode" class="w-full text-xs" rows="8" placeholder="dp = val + sum(children, dp)"></textarea>
        </div>
      </div>

      <div class="space-y-3">
        <div class="flex border-b" style="border-color: var(--border);">
          <button class="tab-btn active" data-tab="output">Output</button>
          <button class="tab-btn" data-tab="data">Data</button>
          <button class="tab-btn" data-tab="docs">Docs</button>
        </div>

        <div id="tab-output" class="tab-content">
          <div class="grid grid-cols-3 gap-2 mb-3">
            <div class="text-center p-2 rounded" style="background: var(--card);">
              <div class="text-xl font-bold mono" style="color: var(--accent);" id="statNodes">0</div>
              <div class="text-xs opacity-60">Nodes</div>
            </div>
            <div class="text-center p-2 rounded" style="background: var(--card);">
              <div class="text-xl font-bold mono" style="color: var(--accent);" id="statEdges">0</div>
              <div class="text-xs opacity-60">Edges</div>
            </div>
            <div class="text-center p-2 rounded" style="background: var(--card);">
              <div class="text-xl font-bold mono" style="color: var(--accent);" id="statRoot">-</div>
              <div class="text-xs opacity-60">Root</div>
            </div>
          </div>
          <div class="output-panel">
            <div class="output-header flex justify-between items-center">
              <span class="text-xs font-semibold">CP Format</span>
              <button id="btnCopy" class="text-xs px-2 py-0.5 rounded" style="background: var(--accent-dim); color: var(--accent); cursor:pointer; border:none;">Copy</button>
            </div>
            <div class="output-content p-3"><pre id="textOutput" class="mono text-xs" style="color: var(--muted);">0 0</pre></div>
          </div>
        </div>

        <div id="tab-data" class="tab-content hidden">
          <div class="output-panel">
            <div class="output-header text-xs font-semibold">Node Table</div>
            <div class="output-content p-2" id="dataTable">Empty</div>
          </div>
        </div>

        <div id="tab-docs" class="tab-content hidden">
          <div class="output-panel">
            <div class="output-header text-xs font-semibold">Documentation</div>
            <div class="output-content p-3 text-xs" id="docsContent"></div>
          </div>
        </div>

        <div id="selInfo" class="hidden p-3 rounded-lg" style="background: var(--card); border: 1px solid var(--border);">
          <div class="flex justify-between items-center mb-2">
            <span class="text-xs font-semibold">Selected: <span id="selName" class="mono" style="color: var(--accent);"></span></span>
            <button id="btnDelSel" class="text-xs px-2 py-0.5 rounded" style="background: var(--danger); cursor:pointer; border:none; color:white;">Del</button>
          </div>
          <label class="block text-xs opacity-60 mb-1">Weight</label>
          <input type="number" id="selWeight" class="w-full">
          <div id="selDpVals" class="hidden mt-2 text-xs"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // =============================================
    // STATE
    // =============================================
    const state = {
      nodes: [], edges: [], nextId: 1,
      mode: 'add', selected: null, connectSource: null, dragging: null,
      isTree: true, isDirected: true, showEdgeW: false,
      dpResults: {}, dpGroups: [],
      display: { id: true, val: true, childCount: false, isLeaf: false }
    };
    const hist = { stack: [], idx: -1 };
    const STORAGE_KEY = 'tree_dp_editor_v2';
    const MAX_TABLE_ROWS = 500;
    let canvas, ctx, displayContainer;

    // =============================================
    // EXAMPLES
    // =============================================
    const EXAMPLES = {
      subtree_size: `# Subtree Size\nsz = sum(children, sz) + 1`,
      subtree_sum: `# Subtree Sum\ndp = val + sum(children, dp)`,
      max_independent: `# Max Independent Set\n# dp0 = not taking this node\n# dp1 = taking this node\ndp0 = sum(children, max({dp0, dp1}))\ndp1 = sum(children, dp0) + val`,
      min_vertex_cover: `# Min Vertex Cover\n# dp0 = node NOT in cover (children must be)\n# dp1 = node IN cover\ndp0 = sum(children, dp1)\ndp1 = sum(children, min({dp0, dp1})) + 1`,
      tree_diameter: `# Tree Diameter\n# down = longest downward path from this node\n# diam = diameter passing through this node\ndown = max(children, down + 1, 0)\ndiam = max(sort(children, down + 1), 0) + (len(children) >= 2 ? sort(children, down + 1)[len(children) - 2] : 0)`,
      sum_of_distances: `# Sum of Distances (Rerooting DP)\n# sz = subtree size, down = sum of distances downward\n# ans = total sum of distances when rerooted here\nsz = sum(children, sz) + 1\ndown = sum(children, down + sz)\nans = par(ans) - sz + (n - sz) + down`,
      tree_matching: `# Tree Matching\n# dp0 = max matching if this node NOT matched\n# dp1 = max matching if this node IS matched to a child\ndp0 = sum(children, max({dp0, dp1}))\ndp1 = max(children, sum(children, max({dp0, dp1})) - max({dp0, dp1}) + dp0 + 1, 0)`,
      tree_coloring: `# Tree Coloring (k=3 colors)\n# dp = number of valid colorings of subtree\n# Each child must differ from parent: (k-1) choices per child\ndp = isLeaf ? 1 : prod(children, 2 * dp)`,
      longest_edge_path: `# Longest Path (Edge Weighted)\n# Enable "Edge W" toggle and set edge weights\ndown = max(children, down + edgeWeight, 0)`
    };

    // =============================================
    // CUSTOM FORMULAS
    // =============================================
    const CUSTOM_FORMULAS_KEY = 'tree_dp_custom_formulas';
    let customFormulas = {};

    function loadCustomFormulas() {
      try {
        const saved = localStorage.getItem(CUSTOM_FORMULAS_KEY);
        if (saved) {
          customFormulas = JSON.parse(saved);
        }
      } catch (e) {
        customFormulas = {};
      }
    }

    function saveCustomFormulas() {
      try {
        localStorage.setItem(CUSTOM_FORMULAS_KEY, JSON.stringify(customFormulas));
      } catch (e) {
        console.error('Failed to save custom formulas:', e);
      }
    }

    function updateDropdownWithCustomFormulas() {
      const select = document.getElementById('dpExamples');
      // Remove old custom options
      const customOptions = Array.from(select.options).filter(opt => opt.dataset.custom === 'true');
      customOptions.forEach(opt => select.removeChild(opt));

      // Add separator if there are custom formulas
      if (Object.keys(customFormulas).length > 0) {
        const separator = document.createElement('option');
        separator.disabled = true;
        separator.textContent = '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ';
        separator.dataset.custom = 'true';
        select.appendChild(separator);

        // Add custom formulas
        Object.keys(customFormulas).sort().forEach(key => {
          const opt = document.createElement('option');
          opt.value = 'custom_' + key;
          opt.textContent = '‚≠ê ' + key;
          opt.dataset.custom = 'true';
          select.appendChild(opt);
        });
      }
    }

    function promptSaveFormula() {
      const code = document.getElementById('dpCode').value.trim();
      if (!code) {
        alert('Please enter a formula first.');
        return;
      }

      let name = prompt('Enter a name for this formula:', '');
      if (!name) return;
      
      name = name.trim();
      if (name === '') return;

      // Check if name conflicts with built-in examples
      if (EXAMPLES[name]) {
        alert('This name conflicts with a built-in example. Please choose a different name.');
        return;
      }

      customFormulas[name] = code;
      saveCustomFormulas();
      updateDropdownWithCustomFormulas();
      alert('Successfully saved formula: ' + name);
    }

    function promptDeleteFormula() {
      if (Object.keys(customFormulas).length === 0) {
        alert('No custom formulas to delete.');
        return;
      }

      const names = Object.keys(customFormulas).sort();
      let message = 'Enter the name of the formula to delete:\n\n';
      names.forEach((name, idx) => {
        message += (idx + 1) + '. ' + name + '\n';
      });

      const name = prompt(message, '');
      if (!name) return;

      const trimmedName = name.trim();
      if (customFormulas[trimmedName]) {
        if (confirm('Delete formula "' + trimmedName + '"?')) {
          delete customFormulas[trimmedName];
          saveCustomFormulas();
          updateDropdownWithCustomFormulas();
          alert('Successfully deleted formula: ' + trimmedName);
        }
      } else {
        alert('Formula not found: ' + trimmedName);
      }
    }

    // =============================================
    // DOCS
    // =============================================
    function buildDocs() {
      const dc = s => `<code class="doc-code">${s}</code>`;
      const sections = [
        { title: 'Variables', items: [
          [dc('val'), 'Node weight.'],
          [dc('children'), 'Array of child node IDs.'],
          [dc('edgeWeight'), 'Edge weight from parent to this node.'],
          [dc('id'), 'Node ID.'],
          [dc('childCount'), 'Number of children.'],
          [dc('isLeaf'), '1 if leaf node, 0 otherwise.'],
          [dc('depth'), 'Depth from root (root = 0).'],
          [dc('subtreeSize'), 'Number of nodes in subtree (including self).'],
          [dc('n'), 'Total number of nodes in the tree.'],
        ]},
        { title: 'Aggregation', items: [
          [dc('sum(arr, expr?)'), 'Sum values. Maps expr over each element if provided.'],
          [dc('prod(arr, expr?)'), 'Product of values.'],
          [dc('max(arr, expr?, def?)'), 'Maximum value. Returns def if empty (default: -Infinity).'],
          [dc('min(arr, expr?, def?)'), 'Minimum value. Returns def if empty (default: Infinity).'],
          [dc('count(arr, expr?)'), 'Count elements (or count where expr ‚â† 0).'],
          [dc('avg(arr, expr?, def?)'), 'Average. Returns def if empty (default: 0).'],
        ]},
        { title: 'Math', items: [
          [dc('abs(x)'), 'Absolute value.'],
          [dc('floor(x)'), 'Floor.'],
          [dc('ceil(x)'), 'Ceiling.'],
          [dc('sqrt(x)'), 'Square root.'],
          [dc('log(x)'), 'Natural logarithm.'],
          [dc('log2(x)'), 'Base-2 logarithm.'],
          [dc('pow(base, exp)'), 'Power.'],
          [dc('mod(a, b)'), 'Modulo (returns 0 if b=0).'],
          [dc('gcd(a, b)'), 'Greatest common divisor.'],
          [dc('lcm(a, b)'), 'Least common multiple.'],
          [dc('sign(x)'), 'Sign: -1, 0, or 1.'],
          [dc('clamp(x, lo, hi)'), 'Clamp x to [lo, hi].'],
        ]},
        { title: 'Access', items: [
          [dc('par(var)'), 'Access a variable on the parent node. Triggers top-down evaluation.'],
          [dc('len(arr)'), 'Array length.'],
          [dc('allNodes()'), 'Returns array of all node IDs in the tree.'],
          [dc('findNodes(condition)'), 'Returns array of node IDs where condition is true. Example: findNodes(val > 5)'],
        ]},
        { title: 'Array Builders', items: [
          [dc('range(n)'), 'Array [0, 1, ..., n-1].'],
          [dc('map(arr, expr)'), 'Map expression over array (element becomes eval context).'],
          [dc('filter(arr, expr)'), 'Keep elements where expr ‚â† 0.'],
          [dc('sort(arr, expr?)'), 'Sort array. If expr provided, sorts by mapped value.'],
          [dc('reverse(arr)'), 'Reverse array.'],
          [dc('concat(a, b)'), 'Concatenate two arrays.'],
          [dc('unique(arr)'), 'Remove duplicate values.'],
          [dc('flatten(arr)'), 'Flatten nested arrays one level.'],
          [dc('prefix(arr, "op")'), 'Prefix accumulation. op: "sum", "max", "min", "prod".'],
          [dc('suffix(arr, "op")'), 'Suffix accumulation.'],
          [dc('slice(arr, start, end?)'), 'Array slice.'],
          [dc('indexOf(arr, val)'), 'Index of value (-1 if not found).'],
        ]},
        { title: 'Arrays', items: [
          [dc('{a, b, c}'), 'Array literal.'],
          [dc('arr[i]'), 'Array indexing (safe: returns 0 if out of bounds).'],
        ]},
        { title: 'Operators', items: [
          [dc('+ - * / % ^'), 'Arithmetic (% = modulo, ^ = power).'],
          [dc('== != &lt; &gt; &lt;= &gt;='), 'Comparison (returns 0 or 1).'],
          [dc('&amp;&amp; || !'), 'Logical AND, OR, NOT.'],
          [dc('cond ? then : else'), 'Ternary conditional.'],
        ]},
      ];
      return sections.map(s => `<div class="doc-section"><span class="doc-section-title">${s.title}</span><ul class="doc-list">${s.items.map(([c, d]) => `<li>${c} ${d}</li>`).join('')}</ul></div>`).join('');
    }

    // =============================================
    // PARSER
    // =============================================
    const Parser = {
      tokenize(code) {
        const tokens = [];
        const regex = /\s*(!=|<=|>=|==|&&|\|\||\.\.|=>|[+\-*\/\^%?:(),.[\]{}<>!]|\d+\.?\d*|"[^"]*"|[a-zA-Z_][a-zA-Z0-9_]*)\s*/g;
        let match;
        while ((match = regex.exec(code)) !== null) if (match[1]) tokens.push(match[1]);
        return tokens;
      },
      parse(code) {
        const tokens = this.tokenize(code);
        let pos = 0;
        const peek = () => tokens[pos];
        const consume = (expected) => {
          const t = tokens[pos++];
          if (expected && t !== expected) throw new Error(`Expected '${expected}' but got '${t || 'EOF'}'`);
          return t;
        };

        const expr = () => {
          let node = or();
          if (peek() === '?') {
            consume();
            const t = expr();
            consume(':');
            const f = expr();
            node = { type: 'ternary', cond: node, t, f };
          }
          return node;
        };
        const or = () => { let l = and(); while (peek() === '||') { consume(); l = { type: 'binop', op: '||', l, r: and() }; } return l; };
        const and = () => { let l = eq(); while (peek() === '&&') { consume(); l = { type: 'binop', op: '&&', l, r: eq() }; } return l; };
        const eq = () => { let l = cmp(); while (peek() === '==' || peek() === '!=') { const op = consume(); l = { type: 'binop', op, l, r: cmp() }; } return l; };
        const cmp = () => { let l = add(); while (['<', '>', '<=', '>='].includes(peek())) { const op = consume(); l = { type: 'binop', op, l, r: add() }; } return l; };
        const add = () => { let l = mul(); while (peek() === '+' || peek() === '-') { const op = consume(); l = { type: 'binop', op, l, r: mul() }; } return l; };
        const mul = () => { let l = modop(); while (peek() === '*' || peek() === '/') { const op = consume(); l = { type: 'binop', op, l, r: modop() }; } return l; };
        const modop = () => { let l = powop(); while (peek() === '%') { consume(); l = { type: 'binop', op: '%', l, r: powop() }; } return l; };
        const powop = () => { let l = unary(); if (peek() === '^') { consume(); return { type: 'binop', op: '^', l, r: powop() }; } return l; };

        const unary = () => {
          if (peek() === '-') { consume(); return { type: 'unary', op: '-', arg: unary() }; }
          if (peek() === '!') { consume(); return { type: 'unary', op: '!', arg: unary() }; }
          return postfix();
        };

        const postfix = () => {
          let node = atom();
          while (peek() === '[') {
            consume();
            const index = expr();
            consume(']');
            node = { type: 'index', target: node, index };
          }
          return node;
        };

        const atom = () => {
          const t = peek();
          if (t === '(') { consume(); const n = expr(); consume(')'); return n; }
          if (t === '{') {
            consume();
            const items = [];
            if (peek() !== '}') { items.push(expr()); while (peek() === ',') { consume(); items.push(expr()); } }
            consume('}');
            return { type: 'array', items };
          }
          if (t && t.startsWith('"')) { consume(); return { type: 'str', val: t.slice(1, -1) }; }
          if (t && /^\d/.test(t)) { consume(); return { type: 'num', val: parseFloat(t) }; }
          if (t && /^[a-zA-Z_]/.test(t)) {
            consume();
            if (peek() === '(') {
              consume();
              const args = [];
              if (peek() !== ')') { args.push(expr()); while (peek() === ',') { consume(); args.push(expr()); } }
              consume(')');
              return { type: 'call', name: t, args };
            }
            return { type: 'var', name: t };
          }
          if (pos < tokens.length) consume(); // skip unknown
          return { type: 'num', val: 0 };
        };

        const result = expr();
        return result;
      }
    };

    // =============================================
    // STORAGE
    // =============================================
    function saveToStorage() {
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify({
          nodes: state.nodes, edges: state.edges, nextId: state.nextId,
          isTree: state.isTree, isDirected: state.isDirected, showEdgeW: state.showEdgeW,
          dpCode: document.getElementById('dpCode').value, display: state.display
        }));
      } catch (e) { /* ignore */ }
    }

    function loadFromStorage() {
      try {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (!saved) return false;
        const data = JSON.parse(saved);
        state.nodes = data.nodes || [];
        state.edges = data.edges || [];
        state.nextId = data.nextId || 1;
        state.isTree = data.isTree !== undefined ? data.isTree : true;
        state.isDirected = data.isDirected !== undefined ? data.isDirected : true;
        state.showEdgeW = data.showEdgeW || false;
        state.display = { ...state.display, ...data.display };
        document.getElementById('dpCode').value = data.dpCode || '';
        document.getElementById('tglTree').classList.toggle('active', state.isTree);
        document.getElementById('tglDirected').classList.toggle('active', state.isDirected);
        document.getElementById('tglShowEdgeW').classList.toggle('active', state.showEdgeW);
        quickParseDpDefs(data.dpCode);
        return true;
      } catch (e) { return false; }
    }

    function resetStorage() { localStorage.removeItem(STORAGE_KEY); location.reload(); }

    function quickParseDpDefs(code) {
      if (!code) return;
      try {
        const groups = {};
        code.split('\n').map(l => l.replace(/#.*$/, '').trim()).filter(l => l.includes('=')).forEach(l => {
          const eqIdx = l.indexOf('=');
          // skip == and !=
          if (l[eqIdx + 1] === '=' || (eqIdx > 0 && l[eqIdx - 1] === '!')) return;
          const lhs = l.substring(0, eqIdx).trim();
          const rhs = l.substring(eqIdx + 1).trim();
          let dpName;
          if (lhs.includes(':')) dpName = lhs.substring(0, lhs.indexOf(':')).trim();
          else dpName = lhs;
          if (!groups[dpName]) groups[dpName] = { name: dpName, lines: [], locals: new Set(), isTopDown: false };
          if (lhs.includes(':')) groups[dpName].locals.add(lhs.split(':')[1].trim());
          try { groups[dpName].lines.push({ target: lhs, ast: Parser.parse(rhs) }); } catch (e) { /* skip */ }
        });
        state.dpGroups = Object.values(groups);
        state.dpGroups.forEach(g => { if (state.display[g.name] === undefined) state.display[g.name] = false; });
      } catch (e) { /* skip */ }
    }

    // =============================================
    // HISTORY
    // =============================================
    const saveHistory = () => {
      hist.stack = hist.stack.slice(0, hist.idx + 1);
      hist.stack.push(JSON.stringify({ nodes: state.nodes, edges: state.edges, nextId: state.nextId }));
      hist.idx++;
      if (hist.stack.length > 30) { hist.stack.shift(); hist.idx--; }
      saveToStorage();
    };
    const undo = () => {
      if (hist.idx > 0) {
        hist.idx--;
        const snap = JSON.parse(hist.stack[hist.idx]);
        state.nodes = snap.nodes; state.edges = snap.edges; state.nextId = snap.nextId;
        state.selected = null; state.dpResults = {}; fullUpdate();
      }
    };
    const redo = () => {
      if (hist.idx < hist.stack.length - 1) {
        hist.idx++;
        const snap = JSON.parse(hist.stack[hist.idx]);
        state.nodes = snap.nodes; state.edges = snap.edges; state.nextId = snap.nextId;
        state.selected = null; state.dpResults = {}; fullUpdate();
      }
    };

    // =============================================
    // GRAPH LOGIC
    // =============================================
    function resize() {
      const rect = canvas.parentElement.getBoundingClientRect();
      canvas.width = Math.max(100, rect.width);
      canvas.height = 400;
      render();
    }

    function setMode(m) {
      state.mode = m; state.connectSource = null;
      document.getElementById('btnAdd').classList.toggle('active', m === 'add');
      document.getElementById('btnConnect').classList.toggle('active', m === 'connect');
      document.getElementById('btnSelect').classList.toggle('active', m === 'select');
      canvas.className = `mode-${m}`;
      render();
    }

    function toggle(k) {
      state[k] = !state[k];
      const map = { isTree: 'tglTree', isDirected: 'tglDirected', showEdgeW: 'tglShowEdgeW' };
      document.getElementById(map[k]).classList.toggle('active', state[k]);
      if (k === 'isTree' && state.isTree && !state.isDirected) toggle('isDirected');
      document.getElementById('dpWarning').classList.toggle('hidden', state.isTree);
      render(); saveToStorage();
    }

    function addNode(x, y) { state.nodes.push({ id: state.nextId++, x, y, weight: 0 }); fullUpdate(); saveHistory(); }

    function addEdge(u, v) {
      if (u.id === v.id) return false;
      if (state.edges.some(e => (e.source === u.id && e.target === v.id) || (!state.isDirected && e.source === v.id && e.target === u.id))) return false;
      if (state.isTree) {
        if (!state.isDirected) return false;
        if (state.edges.some(e => e.target === v.id)) { alert('Node already has parent in Tree Mode.'); return false; }
        if (isReachable(v.id, u.id)) { alert('Cycle detected in Tree Mode.'); return false; }
      }
      state.edges.push({ id: Date.now(), source: u.id, target: v.id, weight: 0 });
      fullUpdate(); saveHistory();
      return true;
    }

    function selectObj(obj) { state.selected = { type: 'node', id: obj.id }; showSelInfo(); render(); }
    function selectEdge(obj) { state.selected = { type: 'edge', id: obj.id }; showSelInfo(); render(); }

    function deleteSelected() {
      if (!state.selected) return;
      if (state.selected.type === 'node') {
        state.nodes = state.nodes.filter(n => n.id !== state.selected.id);
        state.edges = state.edges.filter(e => e.source !== state.selected.id && e.target !== state.selected.id);
      } else {
        state.edges = state.edges.filter(e => e.id !== state.selected.id);
      }
      state.selected = null; state.dpResults = {}; fullUpdate(); saveHistory();
    }

    function updateSelectedWeight(v) {
      const w = parseFloat(v) || 0;
      if (!state.selected) return;
      const obj = state.selected.type === 'node'
        ? state.nodes.find(n => n.id === state.selected.id)
        : state.edges.find(e => e.id === state.selected.id);
      if (obj) obj.weight = w;
      render(); updateOutput(); saveToStorage();
    }

    function fullUpdate() { render(); updateOutput(); showSelInfo(); updateDataTable(); updateDisplayOptions(); }

    function importData() {
      try {
        const text = document.getElementById('importText').value.trim();
        const lines = text.split('\n').map(l => l.trim()).filter(l => l);
        if (!lines.length) return;
        const [V, E] = lines[0].split(/\s+/).map(Number);
        state.nodes = []; state.edges = []; state.nextId = 1; state.dpResults = {}; state.dpGroups = [];
        let hasWeights = false;
        if (lines.length > 1) { const parts = lines[1].split(/\s+/); if (parts.length === V && !isNaN(parts[0])) hasWeights = true; }
        for (let i = 1; i <= V; i++) state.nodes.push({ id: state.nextId++, x: 100 + (i % 5) * 100, y: 100 + Math.floor(i / 5) * 100, weight: 0 });
        if (hasWeights) { const wArr = lines[1].split(/\s+/).map(Number); state.nodes.forEach((n, i) => n.weight = wArr[i] || 0); }
        const startIdx = hasWeights ? 2 : 1;
        for (let i = 0; i < E; i++) {
          if (startIdx + i >= lines.length) break;
          const parts = lines[startIdx + i].split(/\s+/).map(Number);
          if (parts.length >= 2) state.edges.push({ id: Date.now() + i, source: parts[0], target: parts[1], weight: parts[2] || 0 });
        }
        autoLayout(); saveHistory(); fullUpdate();
        document.getElementById('importModal').classList.remove('active');
      } catch (e) { alert('Error parsing data.'); }
    }

    function autoLayout() {
      const V = state.nodes.length;
      if (!V) return;
      const radius = Math.min(canvas.width, canvas.height) * 0.35;
      state.nodes.forEach((n, i) => {
        const angle = (i / V) * 2 * Math.PI - Math.PI / 2;
        n.x = canvas.width / 2 + radius * Math.cos(angle);
        n.y = canvas.height / 2 + radius * Math.sin(angle);
      });
    }

    function isReachable(s, t) {
      const adj = {};
      state.edges.forEach(e => (adj[e.source] = adj[e.source] || []).push(e.target));
      const q = [s], vis = new Set(q);
      while (q.length) { const u = q.shift(); if (u === t) return true; (adj[u] || []).forEach(v => { if (!vis.has(v)) { vis.add(v); q.push(v); } }); }
      return false;
    }

    // =============================================
    // DISPLAY OPTIONS
    // =============================================
    let lastDpsLen = 0;
    function updateDisplayOptions() {
      if (state.dpGroups.length !== lastDpsLen) {
        lastDpsLen = state.dpGroups.length;
        const staticOpts = [
          { key: 'id', label: 'ID' }, { key: 'val', label: 'Weight' },
          { key: 'childCount', label: 'childCount' }, { key: 'isLeaf', label: 'isLeaf' }
        ];
        let html = staticOpts.map(o => `<label class="cb-container"><input type="checkbox" ${state.display[o.key] ? 'checked' : ''} data-opt="${o.key}"><span class="cb-box"></span>${o.label}</label>`).join('');
        if (state.dpGroups.length > 0) {
          html += `<div class="w-full border-t my-1" style="border-color:var(--border)"></div>`;
          html += state.dpGroups.map(g => `<label class="cb-container"><input type="checkbox" ${state.display[g.name] ? 'checked' : ''} data-opt="${g.name}"><span class="cb-box"></span>${g.name}</label>`).join('');
        }
        displayContainer.innerHTML = html;
      }
    }

    // =============================================
    // DP ENGINE
    // =============================================
    function runDP() {
      if (!state.isTree) { alert('DP requires Tree Mode.'); return; }
      const code = document.getElementById('dpCode').value.trim();
      const errorBox = document.getElementById('dpErrorBox');
      errorBox.classList.add('hidden');

      try {
        // Parse groups
        const groups = {};
        code.split('\n').map(l => l.replace(/#.*$/, '').trim()).filter(l => l.includes('=')).forEach(l => {
          const eqIdx = l.indexOf('=');
          if (l[eqIdx + 1] === '=' || (eqIdx > 0 && l[eqIdx - 1] === '!') || (eqIdx > 0 && l[eqIdx - 1] === '<') || (eqIdx > 0 && l[eqIdx - 1] === '>')) return;
          const lhs = l.substring(0, eqIdx).trim();
          const rhs = l.substring(eqIdx + 1).trim();
          let dpName, isLocal = false;
          if (lhs.includes(':')) { dpName = lhs.substring(0, lhs.indexOf(':')).trim(); isLocal = true; } else dpName = lhs;
          if (!groups[dpName]) groups[dpName] = { name: dpName, lines: [], locals: new Set(), isTopDown: false };
          if (isLocal) groups[dpName].locals.add(lhs.split(':')[1].trim());
          try { groups[dpName].lines.push({ target: lhs, ast: Parser.parse(rhs) }); }
          catch (err) { throw new Error(`Parse error in "${l}": ${err.message}`); }
        });

        state.dpGroups = Object.values(groups);
        lastDpsLen = -1;
        updateDisplayOptions();

        // Build tree structures
        const childrenMap = {}, parentMap = {}, edgeWeightMap = {};
        state.nodes.forEach(n => { childrenMap[n.id] = []; parentMap[n.id] = null; edgeWeightMap[n.id] = 0; });
        state.edges.forEach(e => {
          childrenMap[e.source].push(e.target);
          parentMap[e.target] = e.source;
          edgeWeightMap[e.target] = e.weight;
        });

        // Compute depth and subtree size
        const roots = state.nodes.filter(n => !parentMap[n.id]).map(n => n.id);
        const depthMap = {}, sizeMap = {};
        state.nodes.forEach(n => { depthMap[n.id] = 0; sizeMap[n.id] = 1; });

        const computeDepth = (u, d) => { depthMap[u] = d; childrenMap[u].forEach(c => computeDepth(c, d + 1)); };
        roots.forEach(r => computeDepth(r, 0));

        const postOrderIds = [];
        const buildPostOrder = u => { childrenMap[u].forEach(c => buildPostOrder(c)); postOrderIds.push(u); };
        roots.forEach(r => buildPostOrder(r));
        postOrderIds.forEach(u => { sizeMap[u] = 1 + childrenMap[u].reduce((s, c) => s + sizeMap[c], 0); });

        const N = state.nodes.length;

        // Detect top-down
        const hasPar = (node) => {
          if (!node) return false;
          if (node.type === 'call' && node.name === 'par') return true;
          for (const k of ['cond', 't', 'f', 'arg', 'l', 'r', 'target', 'index']) if (node[k] && hasPar(node[k])) return true;
          if (node.args) return node.args.some(hasPar);
          if (node.items) return node.items.some(hasPar);
          return false;
        };
        state.dpGroups.forEach(g => { g.isTopDown = g.lines.some(line => hasPar(line.ast)); });

        // Results
        const results = {};
        state.nodes.forEach(n => results[n.id] = {});

        // GCD helper
        const gcd2 = (a, b) => { a = Math.abs(Math.round(a)); b = Math.abs(Math.round(b)); while (b) { [a, b] = [b, a % b]; } return a; };

        // Resolve variable
        const resolve = (evalNodeId, varName, currentDp, contextNodeId, locals) => {
          const n = state.nodes.find(x => x.id === evalNodeId);
          const children = (n && childrenMap[evalNodeId]) || [];

          if (varName === 'val') return n ? n.weight : 0;
          if (varName === 'id') return evalNodeId;
          if (varName === 'childCount') return children.length;
          if (varName === 'isLeaf') return children.length === 0 ? 1 : 0;
          if (varName === 'children') return children;
          if (varName === 'edgeWeight') return edgeWeightMap[evalNodeId] || 0;
          if (varName === 'depth') return depthMap[evalNodeId] || 0;
          if (varName === 'subtreeSize') return sizeMap[evalNodeId] || 1;
          if (varName === 'n') return N;
          if (locals.has(varName)) return results[contextNodeId][`${currentDp}:${varName}`] || 0;
          return results[evalNodeId]?.[varName] ?? 0;
        };

        // Evaluate AST
        const evalAST = (ast, evalNodeId, currentDp, contextNodeId, locals) => {
          if (!ast) return 0;

          if (ast.type === 'num') return ast.val;
          if (ast.type === 'str') return ast.val;
          if (ast.type === 'var') return resolve(evalNodeId, ast.name, currentDp, contextNodeId, locals);

          if (ast.type === 'ternary') {
            return evalAST(ast.cond, evalNodeId, currentDp, contextNodeId, locals)
              ? evalAST(ast.t, evalNodeId, currentDp, contextNodeId, locals)
              : evalAST(ast.f, evalNodeId, currentDp, contextNodeId, locals);
          }

          if (ast.type === 'unary') {
            const v = evalAST(ast.arg, evalNodeId, currentDp, contextNodeId, locals);
            if (ast.op === '-') return -(Array.isArray(v) ? 0 : v);
            if (ast.op === '!') return (Array.isArray(v) ? 0 : v) ? 0 : 1;
            return 0;
          }

          if (ast.type === 'binop') {
            const l = evalAST(ast.l, evalNodeId, currentDp, contextNodeId, locals);
            const r = evalAST(ast.r, evalNodeId, currentDp, contextNodeId, locals);
            const ln = Array.isArray(l) ? 0 : l;
            const rn = Array.isArray(r) ? 0 : r;
            switch (ast.op) {
              case '+': return ln + rn; case '-': return ln - rn; case '*': return ln * rn;
              case '/': return rn ? ln / rn : 0; case '%': return rn ? ln % rn : 0;
              case '^': return Math.pow(ln, rn);
              case '<': return ln < rn ? 1 : 0; case '>': return ln > rn ? 1 : 0;
              case '<=': return ln <= rn ? 1 : 0; case '>=': return ln >= rn ? 1 : 0;
              case '==': return ln === rn ? 1 : 0; case '!=': return ln !== rn ? 1 : 0;
              case '&&': return (ln && rn) ? 1 : 0; case '||': return (ln || rn) ? 1 : 0;
            }
          }

          if (ast.type === 'array') {
            return ast.items.map(item => evalAST(item, evalNodeId, currentDp, contextNodeId, locals));
          }

          if (ast.type === 'index') {
            const target = evalAST(ast.target, evalNodeId, currentDp, contextNodeId, locals);
            const idx = Math.floor(evalAST(ast.index, evalNodeId, currentDp, contextNodeId, locals));
            if (Array.isArray(target) && idx >= 0 && idx < target.length) return target[idx];
            return 0;
          }

          if (ast.type === 'call') {
            const ev = (a, nid) => evalAST(a, nid !== undefined ? nid : evalNodeId, currentDp, contextNodeId, locals);
            const evSelf = a => ev(a);
            const name = ast.name;
            const args = ast.args;

            // ---- Access ----
            if (name === 'par') {
              const pId = parentMap[evalNodeId]; if (!pId) return 0;
              if (args[0] && args[0].type === 'var') {
                const vn = args[0].name;
                if (vn === 'val') { const pn = state.nodes.find(x => x.id === pId); return pn ? pn.weight : 0; }
                if (vn === 'children') return childrenMap[pId] || [];
                return results[pId]?.[vn] ?? resolve(pId, vn, currentDp, pId, locals);
              }
              return evalAST(args[0], pId, currentDp, contextNodeId, locals);
            }

            if (name === 'len') {
              const a = evSelf(args[0]);
              return Array.isArray(a) ? a.length : 0;
            }

            // ---- Math ----
            if (name === 'abs') return Math.abs(evSelf(args[0]));
            if (name === 'floor') return Math.floor(evSelf(args[0]));
            if (name === 'ceil') return Math.ceil(evSelf(args[0]));
            if (name === 'sqrt') return Math.sqrt(evSelf(args[0]));
            if (name === 'log') return Math.log(evSelf(args[0]));
            if (name === 'log2') return Math.log2(evSelf(args[0]));
            if (name === 'pow') return Math.pow(evSelf(args[0]), evSelf(args[1]));
            if (name === 'mod') { const b = evSelf(args[1]); return b ? evSelf(args[0]) % b : 0; }
            if (name === 'gcd') return gcd2(evSelf(args[0]), evSelf(args[1]));
            if (name === 'lcm') { const a = Math.abs(Math.round(evSelf(args[0]))), b = Math.abs(Math.round(evSelf(args[1]))); return (a && b) ? (a / gcd2(a, b)) * b : 0; }
            if (name === 'sign') { const v = evSelf(args[0]); return v > 0 ? 1 : v < 0 ? -1 : 0; }
            if (name === 'clamp') { const x = evSelf(args[0]), lo = evSelf(args[1]), hi = evSelf(args[2]); return Math.max(lo, Math.min(hi, x)); }

            // ---- Aggregation ----
            if (['sum', 'prod', 'max', 'min', 'count', 'avg'].includes(name)) {
              if (args.length === 0) throw new Error(`${name}() requires at least 1 argument`);
              const arr = evSelf(args[0]);
              if (!Array.isArray(arr)) return 0;

              if (args.length === 1) {
                // Raw values
                if (arr.length === 0) {
                  if (name === 'max') return -Infinity;
                  if (name === 'min') return Infinity;
                  if (name === 'prod') return 1;
                  return 0;
                }
                const nums = arr.map(v => typeof v === 'number' ? v : 0);
                if (name === 'sum') return nums.reduce((a, b) => a + b, 0);
                if (name === 'prod') return nums.reduce((a, b) => a * b, 1);
                if (name === 'max') return Math.max(...nums);
                if (name === 'min') return Math.min(...nums);
                if (name === 'count') return nums.length;
                if (name === 'avg') return nums.reduce((a, b) => a + b, 0) / nums.length;
              }

              const exprAst = args[1];
              const defVal = args.length > 2 ? evSelf(args[2]) : (name === 'max' ? -Infinity : name === 'min' ? Infinity : name === 'prod' ? 1 : 0);

              if (name === 'count') {
                // count with expr: count where expr != 0
                let c = 0;
                for (const item of arr) { if (ev(exprAst, item)) c++; }
                return c;
              }

              const vals = arr.map(item => ev(exprAst, item));
              if (vals.length === 0) return defVal;

              if (name === 'sum') return vals.reduce((a, b) => a + b, 0);
              if (name === 'prod') return vals.reduce((a, b) => a * b, 1);
              if (name === 'max') return Math.max(defVal, ...vals);
              if (name === 'min') return Math.min(defVal, ...vals);
              if (name === 'avg') return vals.reduce((a, b) => a + b, 0) / vals.length;
            }

            // ---- Array builders ----
            if (name === 'range') {
              const n = Math.max(0, Math.floor(evSelf(args[0])));
              return Array.from({ length: Math.min(n, 10000) }, (_, i) => i);
            }

            if (name === 'map') {
              const arr = evSelf(args[0]);
              if (!Array.isArray(arr)) return [];
              return arr.map(item => ev(args[1], item));
            }

            if (name === 'filter') {
              const arr = evSelf(args[0]);
              if (!Array.isArray(arr)) return [];
              return arr.filter(item => ev(args[1], item));
            }

            if (name === 'sort') {
              const arr = evSelf(args[0]);
              if (!Array.isArray(arr)) return [];
              if (args.length < 2) {
                // sort raw values
                return [...arr].sort((a, b) => {
                  const an = typeof a === 'number' ? a : 0;
                  const bn = typeof b === 'number' ? b : 0;
                  return an - bn;
                });
              }
              const exprAst = args[1];
              const vals = arr.map(item => ev(exprAst, item));
              return vals.sort((a, b) => a - b);
            }

            if (name === 'reverse') {
              const arr = evSelf(args[0]);
              return Array.isArray(arr) ? [...arr].reverse() : [];
            }

            if (name === 'concat') {
              const a = evSelf(args[0]), b = evSelf(args[1]);
              return [...(Array.isArray(a) ? a : [a]), ...(Array.isArray(b) ? b : [b])];
            }

            if (name === 'unique') {
              const arr = evSelf(args[0]);
              return Array.isArray(arr) ? [...new Set(arr)] : [];
            }

            if (name === 'flatten') {
              const arr = evSelf(args[0]);
              if (!Array.isArray(arr)) return [];
              const result = [];
              for (const item of arr) {
                if (Array.isArray(item)) result.push(...item);
                else result.push(item);
              }
              return result;
            }

            if (name === 'prefix' || name === 'suffix') {
              const arr = evSelf(args[0]);
              if (!Array.isArray(arr) || arr.length === 0) return [];
              const op = args.length > 1 ? evSelf(args[1]) : 'sum';
              const nums = arr.map(v => typeof v === 'number' ? v : 0);
              const result = new Array(nums.length);
              const apply = (a, b) => {
                if (op === 'sum') return a + b;
                if (op === 'max') return Math.max(a, b);
                if (op === 'min') return Math.min(a, b);
                if (op === 'prod') return a * b;
                return a + b;
              };
              if (name === 'prefix') {
                result[0] = nums[0];
                for (let i = 1; i < nums.length; i++) result[i] = apply(result[i - 1], nums[i]);
              } else {
                result[nums.length - 1] = nums[nums.length - 1];
                for (let i = nums.length - 2; i >= 0; i--) result[i] = apply(nums[i], result[i + 1]);
              }
              return result;
            }

            if (name === 'slice') {
              const arr = evSelf(args[0]);
              if (!Array.isArray(arr)) return [];
              const start = Math.floor(evSelf(args[1]));
              const end = args.length > 2 ? Math.floor(evSelf(args[2])) : arr.length;
              return arr.slice(start, end);
            }

            if (name === 'indexOf') {
              const arr = evSelf(args[0]);
              if (!Array.isArray(arr)) return -1;
              const val = evSelf(args[1]);
              return arr.indexOf(val);
            }

            if (name === 'child') {
              const idx = evSelf(args[0]);
              const children = childrenMap[evalNodeId] || [];
              if (idx >= 0 && idx < children.length) return ev(args[1], children[idx]);
              return 0;
            }

            // ---- Node Filtering ----
            if (name === 'allNodes') {
              return state.nodes.map(n => n.id);
            }

            if (name === 'findNodes') {
              if (args.length === 0) throw new Error('findNodes() requires a condition expression as an argument');
              const result = [];
              for (const node of state.nodes) {
                if (ev(args[0], node.id)) result.push(node.id);
              }
              return result;
            }

            throw new Error(`Unknown function: ${name}`);
          }

          return 0;
        };

        // Execute DP groups
        const postOrder = (u, fn) => { childrenMap[u].forEach(c => postOrder(c, fn)); fn(u); };
        const preOrder = (u, fn) => { fn(u); childrenMap[u].forEach(c => preOrder(c, fn)); };

        state.dpGroups.forEach(g => {
          const fn = u => { g.lines.forEach(line => { results[u][line.target] = evalAST(line.ast, u, g.name, u, g.locals); }); };
          if (g.isTopDown) roots.forEach(r => preOrder(r, fn));
          else roots.forEach(r => postOrder(r, fn));
        });

        state.dpResults = results;
        fullUpdate();
      } catch (err) {
        errorBox.textContent = err.message;
        errorBox.classList.remove('hidden');
      }
    }

    // =============================================
    // RENDER
    // =============================================
    function formatVal(v) {
      if (Array.isArray(v)) return `[${v.map(x => typeof x === 'number' ? (Number.isInteger(x) ? x : x.toFixed(2)) : x).join(', ')}]`;
      if (typeof v === 'number') return Number.isInteger(v) ? String(v) : v.toFixed(2);
      return '-';
    }

    function updateOutput() {
      document.getElementById('statNodes').textContent = state.nodes.length;
      document.getElementById('statEdges').textContent = state.edges.length;
      const hasParent = new Set(state.edges.map(e => e.target));
      document.getElementById('statRoot').textContent = state.nodes.find(n => !hasParent.has(n.id))?.id || '-';
      const lines = [`${state.nodes.length} ${state.edges.length}`];
      if (state.nodes.length) lines.push([...state.nodes].sort((a, b) => a.id - b.id).map(n => n.weight).join(' '));
      state.edges.forEach(e => lines.push(`${e.source} ${e.target}${state.showEdgeW ? ' ' + e.weight : ''}`));
      document.getElementById('textOutput').textContent = lines.join('\n');
    }

    function updateDataTable() {
      const el = document.getElementById('dataTable');
      if (!state.nodes.length) { el.innerHTML = '<p class="p-2 text-xs opacity-60">No data</p>'; return; }
      const rows = [...state.nodes].sort((a, b) => a.id - b.id);
      if (rows.length > MAX_TABLE_ROWS) { el.innerHTML = `<p class="p-2 text-xs opacity-60">Too large (${rows.length}).</p>`; return; }
      el.innerHTML = `<table><thead><tr><th>ID</th><th>W</th>${state.dpGroups.map(g => `<th>${g.name}</th>`).join('')}</tr></thead><tbody>${rows.map(n => `<tr><td style="color:var(--accent)">${n.id}</td><td>${n.weight}</td>${state.dpGroups.map(g => `<td style="color:var(--purple)">${formatVal(state.dpResults[n.id]?.[g.name])}</td>`).join('')}</tr>`).join('')}</tbody></table>`;
    }

    function showSelInfo() {
      const info = document.getElementById('selInfo');
      if (!state.selected) { info.classList.add('hidden'); return; }
      info.classList.remove('hidden');
      const isNode = state.selected.type === 'node';
      const obj = isNode ? state.nodes.find(n => n.id === state.selected.id) : state.edges.find(e => e.id === state.selected.id);
      if (!obj) { info.classList.add('hidden'); return; }
      document.getElementById('selName').textContent = isNode ? `Node ${obj.id}` : `Edge ${obj.source}‚Üí${obj.target}`;
      document.getElementById('selWeight').value = obj.weight;
      const dpVals = document.getElementById('selDpVals');
      if (isNode && state.dpResults[obj.id]) {
        dpVals.classList.remove('hidden');
        dpVals.innerHTML = Object.entries(state.dpResults[obj.id]).filter(([k]) => !k.includes(':')).map(([k, v]) => `<span style="margin-right:8px"><span style="color:var(--accent)">${k}</span>: ${formatVal(v)}</span>`).join('');
      } else dpVals.classList.add('hidden');
    }

    const dist = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);
    function findNode(pos) { return [...state.nodes].reverse().find(n => dist(pos, n) <= 20); }
    function findEdge(pos) {
      let minD = 15, found = null;
      for (const e of state.edges) {
        const s = state.nodes.find(n => n.id === e.source), t = state.nodes.find(n => n.id === e.target);
        if (!s || !t) continue;
        const d = pLineDist(pos, s, t);
        if (d < minD) { minD = d; found = e; }
      }
      return found;
    }
    function pLineDist(p, a, b) {
      const A = p.x - a.x, B = p.y - a.y, C = b.x - a.x, D = b.y - a.y;
      const dot = A * C + B * D, len = C * C + D * D;
      let param = len ? dot / len : -1;
      let xx, yy;
      if (param < 0) { xx = a.x; yy = a.y; }
      else if (param > 1) { xx = b.x; yy = b.y; }
      else { xx = a.x + param * C; yy = a.y + param * D; }
      return Math.hypot(p.x - xx, p.y - yy);
    }

    function render() {
      if (!canvas || canvas.width === 0) return;
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const childrenMap = {};
      state.nodes.forEach(n => childrenMap[n.id] = []);
      state.edges.forEach(e => { if (childrenMap[e.source]) childrenMap[e.source].push(e.target); });

      // Draw edges
      state.edges.forEach(e => {
        const s = state.nodes.find(n => n.id === e.source);
        const t = state.nodes.find(n => n.id === e.target);
        if (!s || !t) return;
        const ang = Math.atan2(t.y - s.y, t.x - s.x);
        const sel = state.selected?.id === e.id;

        ctx.beginPath();
        ctx.moveTo(s.x + Math.cos(ang) * 20, s.y + Math.sin(ang) * 20);
        ctx.lineTo(t.x - Math.cos(ang) * 24, t.y - Math.sin(ang) * 24);
        ctx.strokeStyle = sel ? '#00d4aa' : '#555';
        ctx.lineWidth = sel ? 3 : 2;
        ctx.stroke();

        if (state.isDirected) {
          const ex = t.x - Math.cos(ang) * 24, ey = t.y - Math.sin(ang) * 24;
          ctx.beginPath();
          ctx.moveTo(ex, ey);
          ctx.lineTo(ex - 10 * Math.cos(ang - Math.PI / 6), ey - 10 * Math.sin(ang - Math.PI / 6));
          ctx.lineTo(ex - 10 * Math.cos(ang + Math.PI / 6), ey - 10 * Math.sin(ang + Math.PI / 6));
          ctx.fillStyle = ctx.strokeStyle;
          ctx.fill();
        }

        if (state.showEdgeW) {
          const mx = (s.x + t.x) / 2, my = (s.y + t.y) / 2;
          ctx.beginPath(); ctx.arc(mx, my, 10, 0, 6.3); ctx.fillStyle = '#1a1a24'; ctx.fill();
          ctx.fillStyle = '#888'; ctx.font = '9px JetBrains Mono, monospace'; ctx.textAlign = 'center'; ctx.fillText(e.weight, mx, my + 3);
        }
      });

      // Draw nodes
      state.nodes.forEach(n => {
        const sel = state.selected?.id === n.id;
        if (sel) { ctx.beginPath(); ctx.arc(n.x, n.y, 26, 0, 6.3); ctx.strokeStyle = '#00d4aa'; ctx.lineWidth = 3; ctx.stroke(); }

        ctx.beginPath(); ctx.arc(n.x, n.y, 20, 0, 6.3); ctx.fillStyle = '#1a1a24'; ctx.fill(); ctx.strokeStyle = '#444'; ctx.lineWidth = 1; ctx.stroke();

        const parts = [];
        if (state.display.val) parts.push(`w:${n.weight}`);
        if (state.display.childCount) parts.push(`c:${(childrenMap[n.id] || []).length}`);
        if (state.display.isLeaf) parts.push(`l:${(childrenMap[n.id] || []).length === 0 ? 1 : 0}`);
        state.dpGroups.forEach(g => {
          if (state.display[g.name]) {
            const val = state.dpResults[n.id]?.[g.name];
            if (val !== undefined) parts.push(`${g.name}:${formatVal(val)}`);
          }
        });

        ctx.textAlign = 'center';
        if (state.display.id) {
          ctx.fillStyle = '#fff'; ctx.font = 'bold 12px JetBrains Mono, monospace';
          ctx.fillText(n.id, n.x, n.y - (parts.length > 0 ? 5 : 4));
        }
        if (parts.length > 0) {
          ctx.fillStyle = '#bd93f9'; ctx.font = '9px JetBrains Mono, monospace';
          ctx.fillText(parts.join(' | '), n.x, n.y + (state.display.id ? 10 : 4));
        }
      });
    }

    // =============================================
    // EVENT BINDING
    // =============================================
    function bindEvents() {
      window.addEventListener('resize', resize);

      window.addEventListener('keydown', e => {
        const active = document.activeElement.tagName;
        if (active === 'INPUT' || active === 'TEXTAREA' || active === 'SELECT') {
          if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') { e.preventDefault(); runDP(); }
          return;
        }
        if (['a', 'c', 's', 'Delete', 'Backspace'].includes(e.key)) e.preventDefault();
        if (e.key === 'a') setMode('add');
        if (e.key === 'c') setMode('connect');
        if (e.key === 's') setMode('select');
        if (e.key === 'Delete' || e.key === 'Backspace') deleteSelected();
        if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undo(); }
        if ((e.ctrlKey || e.metaKey) && e.key === 'y') { e.preventDefault(); redo(); }
      });

      document.getElementById('btnAdd').onclick = () => setMode('add');
      document.getElementById('btnConnect').onclick = () => setMode('connect');
      document.getElementById('btnSelect').onclick = () => setMode('select');

      document.getElementById('tglTreeContainer').onclick = () => toggle('isTree');
      document.getElementById('tglDirectedContainer').onclick = () => toggle('isDirected');
      document.getElementById('tglShowEdgeWContainer').onclick = () => toggle('showEdgeW');

      document.getElementById('btnUndo').onclick = undo;
      document.getElementById('btnRedo').onclick = redo;

      document.getElementById('btnOpenImport').onclick = () => document.getElementById('importModal').classList.add('active');
      document.getElementById('btnModalClose').onclick = () => document.getElementById('importModal').classList.remove('active');
      document.getElementById('btnModalImport').onclick = importData;
      document.getElementById('btnResetSave').onclick = resetStorage;

      document.getElementById('btnDelSel').onclick = deleteSelected;
      document.getElementById('btnRunDp').onclick = runDP;
      document.getElementById('btnSaveFormula').onclick = promptSaveFormula;
      document.getElementById('btnDeleteFormula').onclick = promptDeleteFormula;

      document.getElementById('btnCopy').onclick = () => {
        navigator.clipboard.writeText(document.getElementById('textOutput').textContent);
        const btn = document.getElementById('btnCopy');
        btn.textContent = 'Done'; setTimeout(() => btn.textContent = 'Copy', 1000);
      };

      const selWeightInput = document.getElementById('selWeight');
      selWeightInput.onchange = e => { updateSelectedWeight(e.target.value); saveHistory(); };
      selWeightInput.oninput = e => updateSelectedWeight(e.target.value);

      document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.onclick = () => {
          document.querySelectorAll('.tab-btn').forEach(t => t.classList.remove('active'));
          btn.classList.add('active');
          document.querySelectorAll('.tab-content').forEach(c => c.classList.toggle('hidden', c.id !== `tab-${btn.dataset.tab}`));
        };
      });

      displayContainer.onchange = e => {
        if (e.target.type === 'checkbox' && e.target.dataset.opt) {
          state.display[e.target.dataset.opt] = e.target.checked;
          render(); saveToStorage();
        }
      };

      document.getElementById('dpExamples').onchange = e => {
        const val = e.target.value;
        let code = null;
        
        // Check built-in examples
        if (val && EXAMPLES[val]) {
          code = EXAMPLES[val];
        }
        // Check custom formulas
        else if (val && val.startsWith('custom_')) {
          const customKey = val.substring(7); // Remove 'custom_' prefix
          if (customFormulas[customKey]) {
            code = customFormulas[customKey];
          }
        }
        
        if (code) {
          document.getElementById('dpCode').value = code;
          quickParseDpDefs(code);
          lastDpsLen = -1;
          updateDisplayOptions();
          saveToStorage();
        }
        e.target.value = '';
      };

      // Canvas mouse events
      canvas.onmousedown = ev => {
        const pos = { x: ev.offsetX, y: ev.offsetY };
        const node = findNode(pos);
        const edge = findEdge(pos);

        if (state.mode === 'add') {
          if (!node) addNode(pos.x, pos.y);
          else selectObj(node);
        } else if (state.mode === 'connect') {
          if (node) {
            if (!state.connectSource) state.connectSource = node;
            else { addEdge(state.connectSource, node); state.connectSource = null; }
          } else state.connectSource = null;
          render();
        } else {
          if (node) {
            state.dragging = { id: node.id, ox: pos.x - node.x, oy: pos.y - node.y };
            selectObj(node);
          } else if (edge) {
            selectEdge(edge);
          } else {
            state.selected = null;
            showSelInfo();
          }
          render();
        }
      };

      canvas.onmousemove = ev => {
        if (state.dragging) {
          const n = state.nodes.find(x => x.id === state.dragging.id);
          if (n) { n.x = ev.offsetX - state.dragging.ox; n.y = ev.offsetY - state.dragging.oy; render(); }
        }
      };

      const stopDrag = () => { if (state.dragging) saveHistory(); state.dragging = null; };
      canvas.onmouseup = stopDrag;
      canvas.onmouseleave = stopDrag;
    }

    // =============================================
    // INIT
    // =============================================
    function init() {
      canvas = document.getElementById('graphCanvas');
      ctx = canvas.getContext('2d');
      displayContainer = document.getElementById('displayOptionsContainer');

      document.getElementById('docsContent').innerHTML = buildDocs();

      loadCustomFormulas();
      loadFromStorage();
      updateDropdownWithCustomFormulas();
      resize();
      bindEvents();
      saveHistory();
      fullUpdate();
      setMode('add');

      if (!document.getElementById('dpCode').value) {
        document.getElementById('dpCode').value = EXAMPLES.subtree_sum;
        quickParseDpDefs(EXAMPLES.subtree_sum);
        updateDisplayOptions();
      }
    }

    init();
  </script>
</body>
</html>
