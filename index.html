<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tree DP & Graph Editor</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&family=Space+Grotesk:wght@400;500;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
</head>
<body class="p-4 md:p-6">

  <div id="importModal" class="modal-overlay">
    <div class="modal">
      <h3 class="font-bold text-lg mb-2">Import / Reset</h3>
      <p class="text-xs mb-2" style="color:var(--muted)">Format A (edge list): Line 1 is <code>V E</code>, Line 2 is V weights, then E lines of edges (<code>u v w</code>).<br>Format B (parent array): Line 1 is <code>n</code>, Line 2 is n weights, Line 3 is <code>p2 p3 ‚Ä¶ pn</code> (parent of each node).</p>
      <textarea id="importText" class="w-full" rows="6" placeholder="3 2&#10;1 2 3&#10;1 2 1&#10;2 3 1"></textarea>
      <div class="flex justify-end gap-2 mt-3">
        <button id="btnResetSave" class="btn px-3 py-1.5 rounded text-xs mr-auto" style="background: var(--danger); color: white;">Reset Save</button>
        <button id="btnModalClose" class="btn px-3 py-1.5 rounded text-xs" style="background:var(--border)">Cancel</button>
        <button id="btnModalImport" class="btn px-3 py-1.5 rounded text-xs" style="background:var(--accent); color:var(--bg)">Import</button>
      </div>
    </div>
  </div>

  <div class="max-w-7xl mx-auto">
    <header class="mb-4">
      <h1 class="text-2xl md:text-3xl font-bold tracking-tight">Graph <span style="color: var(--accent);">Editor</span> & DP</h1>
    </header>

    <div class="grid lg:grid-cols-3 gap-4">
      <div class="lg:col-span-2 space-y-3">
        <div class="p-3 rounded-lg flex flex-col gap-3" style="background: var(--card); border: 1px solid var(--border);">
          <div class="flex flex-wrap gap-2 items-center justify-between">
            <div class="flex gap-2">
              <button id="btnAdd" class="mode-btn btn px-3 py-1.5 rounded text-xs font-medium">Add (A)</button>
              <button id="btnConnect" class="mode-btn btn px-3 py-1.5 rounded text-xs font-medium">Connect (C)</button>
              <button id="btnSelect" class="mode-btn btn px-3 py-1.5 rounded text-xs font-medium">Edit (S)</button>
            </div>
            <div class="flex gap-2">
              <button id="btnUndo" class="btn text-xs px-2 py-1 rounded" style="background: var(--border); color: var(--fg);">Undo</button>
              <button id="btnRedo" class="btn text-xs px-2 py-1 rounded" style="background: var(--border); color: var(--fg);">Redo</button>
              <button id="btnOpenImport" class="btn text-xs px-2 py-1 rounded" style="background: var(--border); color: var(--fg);">Menu</button>
            </div>
          </div>
          <div class="flex flex-wrap gap-x-6 gap-y-2 items-center border-t pt-3" style="border-color: var(--border);">
            <div class="flex gap-4">
              <div id="tglTreeContainer" class="toggle-container"><div id="tglTree" class="toggle-switch active"></div><span>Tree</span></div>
              <div id="tglDirectedContainer" class="toggle-container"><div id="tglDirected" class="toggle-switch active"></div><span>Directed</span></div>
              <div id="tglShowEdgeWContainer" class="toggle-container"><div id="tglShowEdgeW" class="toggle-switch"></div><span>Edge W</span></div>
            </div>
          </div>
        </div>

        <div class="canvas-container bg-grid">
          <canvas id="graphCanvas"></canvas>
        </div>

        <div class="p-3 rounded-lg" style="background: var(--card); border: 1px solid var(--border);">
          <div class="text-xs font-semibold mb-2 opacity-70">Vertex Content</div>
          <div id="displayOptionsContainer" class="flex flex-wrap gap-3"></div>
        </div>

        <div class="p-3 rounded-lg" style="background: var(--card); border: 1px solid var(--border);">
          <div class="flex justify-between items-center mb-2">
            <div class="flex items-center gap-2">
              <h3 class="font-semibold text-sm">DP Formulas</h3>
              <select id="dpExamples" class="text-xs py-1 px-2" style="font-family: 'Space Grotesk', sans-serif;">
                <option value="">Examples...</option>
                <option value="subtree_size">Subtree Size</option>
                <option value="subtree_sum">Subtree Sum</option>
                <option value="max_independent">Max Independent Set</option>
                <option value="min_vertex_cover">Min Vertex Cover</option>
                <option value="tree_diameter">Tree Diameter</option>
                <option value="sum_of_distances">Sum of Distances (Rerooting)</option>
                <option value="tree_matching">Tree Matching</option>
                <option value="tree_coloring">Tree Coloring (k=3)</option>
                <option value="longest_edge_path">Longest Path (Edge W)</option>
              </select>
            </div>
            <div class="flex gap-2">
              <button id="btnSaveFormula" class="btn text-xs px-2 py-1 rounded font-medium" style="background: var(--border); color: var(--text);" title="Save current formula">üíæ</button>
              <button id="btnDeleteFormula" class="btn text-xs px-2 py-1 rounded font-medium" style="background: var(--border); color: var(--text);" title="Delete saved formula">üóëÔ∏è</button>
              <button id="btnRunDp" class="btn text-xs px-3 py-1 rounded font-medium" style="background: var(--accent); color: var(--bg);">Run (Ctrl+Enter)</button>
            </div>
          </div>
          <div id="dpErrorBox" class="error-box hidden"></div>
          <div id="dpWarning" class="hidden text-xs mb-2 p-2 rounded" style="background: rgba(255,170,0,0.2); color: var(--orange);">Warning: Tree Mode is disabled. DP requires a tree structure.</div>
          <textarea id="dpCode" class="w-full text-xs" rows="8" placeholder="dp = val + sum(children, dp)"></textarea>
        </div>
      </div>

      <div class="space-y-3">
        <div class="flex border-b" style="border-color: var(--border);">
          <button class="tab-btn active" data-tab="output">Output</button>
          <button class="tab-btn" data-tab="data">Data</button>
          <button class="tab-btn" data-tab="docs">Docs</button>
        </div>

        <div id="tab-output" class="tab-content">
          <div class="grid grid-cols-3 gap-2 mb-3">
            <div class="text-center p-2 rounded" style="background: var(--card);">
              <div class="text-xl font-bold mono" style="color: var(--accent);" id="statNodes">0</div>
              <div class="text-xs opacity-60">Nodes</div>
            </div>
            <div class="text-center p-2 rounded" style="background: var(--card);">
              <div class="text-xl font-bold mono" style="color: var(--accent);" id="statEdges">0</div>
              <div class="text-xs opacity-60">Edges</div>
            </div>
            <div class="text-center p-2 rounded" style="background: var(--card);">
              <div class="text-xl font-bold mono" style="color: var(--accent);" id="statRoot">-</div>
              <div class="text-xs opacity-60">Root</div>
            </div>
          </div>
          <div class="output-panel">
            <div class="output-header flex justify-between items-center">
              <span class="text-xs font-semibold">CP Format</span>
              <button id="btnCopy" class="text-xs px-2 py-0.5 rounded" style="background: var(--accent-dim); color: var(--accent); cursor:pointer; border:none;">Copy</button>
            </div>
            <div class="output-content p-3"><pre id="textOutput" class="mono text-xs" style="color: var(--muted);">0 0</pre></div>
          </div>
        </div>

        <div id="tab-data" class="tab-content hidden">
          <div class="output-panel">
            <div class="output-header text-xs font-semibold">Node Table</div>
            <div class="output-content p-2" id="dataTable">Empty</div>
          </div>
        </div>

        <div id="tab-docs" class="tab-content hidden">
          <div class="output-panel">
            <div class="output-header text-xs font-semibold">Documentation</div>
            <div class="output-content p-3 text-xs" id="docsContent"></div>
          </div>
        </div>

        <div id="selInfo" class="hidden p-3 rounded-lg" style="background: var(--card); border: 1px solid var(--border);">
          <div class="flex justify-between items-center mb-2">
            <span class="text-xs font-semibold">Selected: <span id="selName" class="mono" style="color: var(--accent);"></span></span>
            <button id="btnDelSel" class="text-xs px-2 py-0.5 rounded" style="background: var(--danger); cursor:pointer; border:none; color:white;">Del</button>
          </div>
          <label class="block text-xs opacity-60 mb-1">Weight</label>
          <input type="number" id="selWeight" class="w-full">
          <div id="selDpVals" class="hidden mt-2 text-xs"></div>
        </div>
      </div>
    </div>
  </div>

  <script src="dp-engine.js"></script>
  <script>
    // =============================================
    // STATE
    // =============================================
    const state = {
      nodes: [], edges: [], nextId: 1,
      mode: 'add', selected: null, connectSource: null, dragging: null,
      isTree: true, isDirected: true, showEdgeW: false,
      dpResults: {}, dpGroups: [],
      display: { id: true, val: true, childCount: false, isLeaf: false }
    };
    const hist = { stack: [], idx: -1 };
    const STORAGE_KEY = 'tree_dp_editor_v2';
    const MAX_TABLE_ROWS = 500;
    let canvas, ctx, displayContainer;

    // =============================================
    // CUSTOM FORMULAS
    // =============================================
    const CUSTOM_FORMULAS_KEY = 'tree_dp_custom_formulas';
    let customFormulas = {};

    function loadCustomFormulas() {
      try {
        const saved = localStorage.getItem(CUSTOM_FORMULAS_KEY);
        if (saved) {
          customFormulas = JSON.parse(saved);
        }
      } catch (e) {
        customFormulas = {};
      }
    }

    function saveCustomFormulas() {
      try {
        localStorage.setItem(CUSTOM_FORMULAS_KEY, JSON.stringify(customFormulas));
      } catch (e) {
        console.error('Failed to save custom formulas:', e);
      }
    }

    function updateDropdownWithCustomFormulas() {
      const select = document.getElementById('dpExamples');
      // Remove old custom options
      const customOptions = Array.from(select.options).filter(opt => opt.dataset.custom === 'true');
      customOptions.forEach(opt => select.removeChild(opt));

      // Add separator if there are custom formulas
      if (Object.keys(customFormulas).length > 0) {
        const separator = document.createElement('option');
        separator.disabled = true;
        separator.textContent = '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ';
        separator.dataset.custom = 'true';
        select.appendChild(separator);

        // Add custom formulas
        Object.keys(customFormulas).sort().forEach(key => {
          const opt = document.createElement('option');
          opt.value = 'custom_' + key;
          opt.textContent = '‚≠ê ' + key;
          opt.dataset.custom = 'true';
          select.appendChild(opt);
        });
      }
    }

    function promptSaveFormula() {
      const code = document.getElementById('dpCode').value.trim();
      if (!code) {
        alert('Please enter a formula first.');
        return;
      }

      let name = prompt('Enter a name for this formula:', '');
      if (!name) return;
      
      name = name.trim();
      if (name === '') return;

      // Check if name conflicts with built-in examples
      if (EXAMPLES[name]) {
        alert('This name conflicts with a built-in example. Please choose a different name.');
        return;
      }

      customFormulas[name] = code;
      saveCustomFormulas();
      updateDropdownWithCustomFormulas();
      alert('Successfully saved formula: ' + name);
    }

    function promptDeleteFormula() {
      if (Object.keys(customFormulas).length === 0) {
        alert('No custom formulas to delete.');
        return;
      }

      const names = Object.keys(customFormulas).sort();
      let message = 'Enter the name of the formula to delete:\n\n';
      names.forEach((name, idx) => {
        message += (idx + 1) + '. ' + name + '\n';
      });

      const name = prompt(message, '');
      if (!name) return;

      const trimmedName = name.trim();
      if (customFormulas[trimmedName]) {
        if (confirm('Delete formula "' + trimmedName + '"?')) {
          delete customFormulas[trimmedName];
          saveCustomFormulas();
          updateDropdownWithCustomFormulas();
          alert('Successfully deleted formula: ' + trimmedName);
        }
      } else {
        alert('Formula not found: ' + trimmedName);
      }
    }

    // =============================================
    // STORAGE
    // =============================================
    function saveToStorage() {
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify({
          nodes: state.nodes, edges: state.edges, nextId: state.nextId,
          isTree: state.isTree, isDirected: state.isDirected, showEdgeW: state.showEdgeW,
          dpCode: document.getElementById('dpCode').value, display: state.display
        }));
      } catch (e) { /* ignore */ }
    }

    function loadFromStorage() {
      try {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (!saved) return false;
        const data = JSON.parse(saved);
        state.nodes = data.nodes || [];
        state.edges = data.edges || [];
        state.nextId = data.nextId || 1;
        state.isTree = data.isTree !== undefined ? data.isTree : true;
        state.isDirected = data.isDirected !== undefined ? data.isDirected : true;
        state.showEdgeW = data.showEdgeW || false;
        state.display = { ...state.display, ...data.display };
        document.getElementById('dpCode').value = data.dpCode || '';
        document.getElementById('tglTree').classList.toggle('active', state.isTree);
        document.getElementById('tglDirected').classList.toggle('active', state.isDirected);
        document.getElementById('tglShowEdgeW').classList.toggle('active', state.showEdgeW);
        document.getElementById('dpWarning').classList.toggle('hidden', state.isTree);
        quickParseDpDefs(data.dpCode);
        return true;
      } catch (e) { return false; }
    }

    function resetStorage() { localStorage.removeItem(STORAGE_KEY); location.reload(); }

    // =============================================
    // HISTORY
    // =============================================
    const saveHistory = () => {
      hist.stack = hist.stack.slice(0, hist.idx + 1);
      hist.stack.push(JSON.stringify({ nodes: state.nodes, edges: state.edges, nextId: state.nextId }));
      hist.idx++;
      if (hist.stack.length > 30) { hist.stack.shift(); hist.idx--; }
      saveToStorage();
    };
    const undo = () => {
      if (hist.idx > 0) {
        hist.idx--;
        const snap = JSON.parse(hist.stack[hist.idx]);
        state.nodes = snap.nodes; state.edges = snap.edges; state.nextId = snap.nextId;
        state.selected = null; state.dpResults = {}; fullUpdate();
      }
    };
    const redo = () => {
      if (hist.idx < hist.stack.length - 1) {
        hist.idx++;
        const snap = JSON.parse(hist.stack[hist.idx]);
        state.nodes = snap.nodes; state.edges = snap.edges; state.nextId = snap.nextId;
        state.selected = null; state.dpResults = {}; fullUpdate();
      }
    };

    // =============================================
    // GRAPH LOGIC
    // =============================================
    function resize() {
      const rect = canvas.parentElement.getBoundingClientRect();
      canvas.width = Math.max(100, rect.width);
      canvas.height = 400;
      render();
    }

    function setMode(m) {
      state.mode = m; state.connectSource = null;
      document.getElementById('btnAdd').classList.toggle('active', m === 'add');
      document.getElementById('btnConnect').classList.toggle('active', m === 'connect');
      document.getElementById('btnSelect').classList.toggle('active', m === 'select');
      canvas.className = `mode-${m}`;
      render();
    }

    function toggle(k) {
      state[k] = !state[k];
      const map = { isTree: 'tglTree', isDirected: 'tglDirected', showEdgeW: 'tglShowEdgeW' };
      document.getElementById(map[k]).classList.toggle('active', state[k]);
      if (k === 'isTree' && state.isTree && !state.isDirected) toggle('isDirected');
      document.getElementById('dpWarning').classList.toggle('hidden', state.isTree);
      render(); saveToStorage();
    }

    function addNode(x, y) { state.nodes.push({ id: state.nextId++, x, y, weight: 0 }); fullUpdate(); saveHistory(); }

    function addEdge(u, v) {
      if (u.id === v.id) return false;
      if (state.edges.some(e => (e.source === u.id && e.target === v.id) || (!state.isDirected && e.source === v.id && e.target === u.id))) return false;
      if (state.isTree) {
        if (!state.isDirected) return false;
        if (state.edges.some(e => e.target === v.id)) { alert('Node already has parent in Tree Mode.'); return false; }
        if (isReachable(v.id, u.id)) { alert('Cycle detected in Tree Mode.'); return false; }
      }
      state.edges.push({ id: Date.now(), source: u.id, target: v.id, weight: 0 });
      fullUpdate(); saveHistory();
      return true;
    }

    function selectObj(obj) { state.selected = { type: 'node', id: obj.id }; showSelInfo(); render(); }
    function selectEdge(obj) { state.selected = { type: 'edge', id: obj.id }; showSelInfo(); render(); }

    function deleteSelected() {
      if (!state.selected) return;
      if (state.selected.type === 'node') {
        state.nodes = state.nodes.filter(n => n.id !== state.selected.id);
        state.edges = state.edges.filter(e => e.source !== state.selected.id && e.target !== state.selected.id);
      } else {
        state.edges = state.edges.filter(e => e.id !== state.selected.id);
      }
      state.selected = null; state.dpResults = {}; fullUpdate(); saveHistory();
    }

    function updateSelectedWeight(v) {
      const w = parseFloat(v) || 0;
      if (!state.selected) return;
      const obj = state.selected.type === 'node'
        ? state.nodes.find(n => n.id === state.selected.id)
        : state.edges.find(e => e.id === state.selected.id);
      if (obj) obj.weight = w;
      render(); updateOutput(); saveToStorage();
    }

    function fullUpdate() { render(); updateOutput(); showSelInfo(); updateDataTable(); updateDisplayOptions(); }

    function importData() {
      try {
        const text = document.getElementById('importText').value.trim();
        const lines = text.split('\n').map(l => l.trim()).filter(l => l);
        if (!lines.length) return;
        const firstParts = lines[0].split(/\s+/).map(Number);
        state.nodes = []; state.edges = []; state.nextId = 1; state.dpResults = {}; state.dpGroups = [];
        if (firstParts.length === 1) {
          // Format B: parent array format
          const n = firstParts[0];
          if (isNaN(n) || n < 1) throw new Error('Invalid n');
          const wArr = lines.length > 1 ? lines[1].split(/\s+/).map(Number) : [];
          if (wArr.length !== n) throw new Error('Weight count mismatch');
          for (let i = 1; i <= n; i++) state.nodes.push({ id: state.nextId++, x: 100 + (i % 5) * 100, y: 100 + Math.floor(i / 5) * 100, weight: wArr[i - 1] || 0 });
          if (n > 1) {
            const parents = lines.length > 2 ? lines[2].split(/\s+/).map(Number) : [];
            if (parents.length !== n - 1) throw new Error('Parent count mismatch');
            parents.forEach((p, idx) => {
              state.edges.push({ id: Date.now() + idx, source: p, target: idx + 2, weight: 0 });
            });
          }
        } else {
          // Format A: edge list format
          const [V, E] = firstParts;
          let hasWeights = false;
          if (lines.length > 1) { const parts = lines[1].split(/\s+/); if (parts.length === V && !isNaN(parts[0])) hasWeights = true; }
          for (let i = 1; i <= V; i++) state.nodes.push({ id: state.nextId++, x: 100 + (i % 5) * 100, y: 100 + Math.floor(i / 5) * 100, weight: 0 });
          if (hasWeights) { const wArr = lines[1].split(/\s+/).map(Number); state.nodes.forEach((n, i) => n.weight = wArr[i] || 0); }
          const startIdx = hasWeights ? 2 : 1;
          for (let i = 0; i < E; i++) {
            if (startIdx + i >= lines.length) break;
            const parts = lines[startIdx + i].split(/\s+/).map(Number);
            if (parts.length >= 2) state.edges.push({ id: Date.now() + i, source: parts[0], target: parts[1], weight: parts[2] || 0 });
          }
        }
        autoLayout(); saveHistory(); fullUpdate();
        document.getElementById('importModal').classList.remove('active');
      } catch (e) { alert('Error parsing data.'); }
    }

    function autoLayout() {
      const V = state.nodes.length;
      if (!V) return;
      const radius = Math.min(canvas.width, canvas.height) * 0.35;
      state.nodes.forEach((n, i) => {
        const angle = (i / V) * 2 * Math.PI - Math.PI / 2;
        n.x = canvas.width / 2 + radius * Math.cos(angle);
        n.y = canvas.height / 2 + radius * Math.sin(angle);
      });
    }

    function isReachable(s, t) {
      const adj = {};
      state.edges.forEach(e => (adj[e.source] = adj[e.source] || []).push(e.target));
      const q = [s], vis = new Set(q);
      while (q.length) { const u = q.shift(); if (u === t) return true; (adj[u] || []).forEach(v => { if (!vis.has(v)) { vis.add(v); q.push(v); } }); }
      return false;
    }

    // =============================================
    // DISPLAY OPTIONS
    // =============================================
    let lastDpsLen = 0;
    function updateDisplayOptions() {
      if (state.dpGroups.length !== lastDpsLen) {
        lastDpsLen = state.dpGroups.length;
        const staticOpts = [
          { key: 'id', label: 'ID' }, { key: 'val', label: 'Weight' },
          { key: 'childCount', label: 'childCount' }, { key: 'isLeaf', label: 'isLeaf' }
        ];
        let html = staticOpts.map(o => `<label class="cb-container"><input type="checkbox" ${state.display[o.key] ? 'checked' : ''} data-opt="${o.key}"><span class="cb-box"></span>${o.label}</label>`).join('');
        if (state.dpGroups.length > 0) {
          html += `<div class="w-full border-t my-1" style="border-color:var(--border)"></div>`;
          html += state.dpGroups.map(g => `<label class="cb-container"><input type="checkbox" ${state.display[g.name] ? 'checked' : ''} data-opt="${g.name}"><span class="cb-box"></span>${g.name}</label>`).join('');
        }
        displayContainer.innerHTML = html;
      }
    }

    // =============================================
    // RENDER
    // =============================================
    function formatVal(v) {
      if (Array.isArray(v)) return `[${v.map(x => typeof x === 'number' ? (Number.isInteger(x) ? x : x.toFixed(2)) : x).join(', ')}]`;
      if (typeof v === 'number') return Number.isInteger(v) ? String(v) : v.toFixed(2);
      return '-';
    }

    function updateOutput() {
      document.getElementById('statNodes').textContent = state.nodes.length;
      document.getElementById('statEdges').textContent = state.edges.length;
      const hasParent = new Set(state.edges.map(e => e.target));
      document.getElementById('statRoot').textContent = state.nodes.find(n => !hasParent.has(n.id))?.id || '-';
      const lines = [`${state.nodes.length} ${state.edges.length}`];
      if (state.nodes.length) lines.push([...state.nodes].sort((a, b) => a.id - b.id).map(n => n.weight).join(' '));
      state.edges.forEach(e => lines.push(`${e.source} ${e.target}${state.showEdgeW ? ' ' + e.weight : ''}`));
      document.getElementById('textOutput').textContent = lines.join('\n');
    }

    function updateDataTable() {
      const el = document.getElementById('dataTable');
      if (!state.nodes.length) { el.innerHTML = '<p class="p-2 text-xs opacity-60">No data</p>'; return; }
      const rows = [...state.nodes].sort((a, b) => a.id - b.id);
      if (rows.length > MAX_TABLE_ROWS) { el.innerHTML = `<p class="p-2 text-xs opacity-60">Too large (${rows.length}).</p>`; return; }
      el.innerHTML = `<table><thead><tr><th>ID</th><th>W</th>${state.dpGroups.map(g => `<th>${g.name}</th>`).join('')}</tr></thead><tbody>${rows.map(n => `<tr><td style="color:var(--accent)">${n.id}</td><td>${n.weight}</td>${state.dpGroups.map(g => `<td style="color:var(--purple)">${formatVal(state.dpResults[n.id]?.[g.name])}</td>`).join('')}</tr>`).join('')}</tbody></table>`;
    }

    function showSelInfo() {
      const info = document.getElementById('selInfo');
      if (!state.selected) { info.classList.add('hidden'); return; }
      info.classList.remove('hidden');
      const isNode = state.selected.type === 'node';
      const obj = isNode ? state.nodes.find(n => n.id === state.selected.id) : state.edges.find(e => e.id === state.selected.id);
      if (!obj) { info.classList.add('hidden'); return; }
      document.getElementById('selName').textContent = isNode ? `Node ${obj.id}` : `Edge ${obj.source}‚Üí${obj.target}`;
      document.getElementById('selWeight').value = obj.weight;
      const dpVals = document.getElementById('selDpVals');
      if (isNode && state.dpResults[obj.id]) {
        dpVals.classList.remove('hidden');
        dpVals.innerHTML = Object.entries(state.dpResults[obj.id]).filter(([k]) => !k.includes(':')).map(([k, v]) => `<span style="margin-right:8px"><span style="color:var(--accent)">${k}</span>: ${formatVal(v)}</span>`).join('');
      } else dpVals.classList.add('hidden');
    }

    const dist = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);
    function findNode(pos) { return [...state.nodes].reverse().find(n => dist(pos, n) <= 20); }
    function findEdge(pos) {
      let minD = 15, found = null;
      for (const e of state.edges) {
        const s = state.nodes.find(n => n.id === e.source), t = state.nodes.find(n => n.id === e.target);
        if (!s || !t) continue;
        const d = pLineDist(pos, s, t);
        if (d < minD) { minD = d; found = e; }
      }
      return found;
    }
    function pLineDist(p, a, b) {
      const A = p.x - a.x, B = p.y - a.y, C = b.x - a.x, D = b.y - a.y;
      const dot = A * C + B * D, len = C * C + D * D;
      let param = len ? dot / len : -1;
      let xx, yy;
      if (param < 0) { xx = a.x; yy = a.y; }
      else if (param > 1) { xx = b.x; yy = b.y; }
      else { xx = a.x + param * C; yy = a.y + param * D; }
      return Math.hypot(p.x - xx, p.y - yy);
    }

    function render() {
      if (!canvas || canvas.width === 0) return;
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const childrenMap = {};
      state.nodes.forEach(n => childrenMap[n.id] = []);
      state.edges.forEach(e => { if (childrenMap[e.source]) childrenMap[e.source].push(e.target); });

      // Draw edges
      state.edges.forEach(e => {
        const s = state.nodes.find(n => n.id === e.source);
        const t = state.nodes.find(n => n.id === e.target);
        if (!s || !t) return;
        const ang = Math.atan2(t.y - s.y, t.x - s.x);
        const sel = state.selected?.id === e.id;

        ctx.beginPath();
        ctx.moveTo(s.x + Math.cos(ang) * 20, s.y + Math.sin(ang) * 20);
        ctx.lineTo(t.x - Math.cos(ang) * 24, t.y - Math.sin(ang) * 24);
        ctx.strokeStyle = sel ? '#00d4aa' : '#555';
        ctx.lineWidth = sel ? 3 : 2;
        ctx.stroke();

        if (state.isDirected) {
          const ex = t.x - Math.cos(ang) * 24, ey = t.y - Math.sin(ang) * 24;
          ctx.beginPath();
          ctx.moveTo(ex, ey);
          ctx.lineTo(ex - 10 * Math.cos(ang - Math.PI / 6), ey - 10 * Math.sin(ang - Math.PI / 6));
          ctx.lineTo(ex - 10 * Math.cos(ang + Math.PI / 6), ey - 10 * Math.sin(ang + Math.PI / 6));
          ctx.fillStyle = ctx.strokeStyle;
          ctx.fill();
        }

        if (state.showEdgeW) {
          const mx = (s.x + t.x) / 2, my = (s.y + t.y) / 2;
          ctx.beginPath(); ctx.arc(mx, my, 10, 0, 6.3); ctx.fillStyle = '#1a1a24'; ctx.fill();
          ctx.fillStyle = '#888'; ctx.font = '9px JetBrains Mono, monospace'; ctx.textAlign = 'center'; ctx.fillText(e.weight, mx, my + 3);
        }
      });

      // Draw nodes
      state.nodes.forEach(n => {
        const sel = state.selected?.id === n.id;
        if (sel) { ctx.beginPath(); ctx.arc(n.x, n.y, 26, 0, 6.3); ctx.strokeStyle = '#00d4aa'; ctx.lineWidth = 3; ctx.stroke(); }

        ctx.beginPath(); ctx.arc(n.x, n.y, 20, 0, 6.3); ctx.fillStyle = '#1a1a24'; ctx.fill(); ctx.strokeStyle = '#444'; ctx.lineWidth = 1; ctx.stroke();

        const parts = [];
        if (state.display.val) parts.push(`w:${n.weight}`);
        if (state.display.childCount) parts.push(`c:${(childrenMap[n.id] || []).length}`);
        if (state.display.isLeaf) parts.push(`l:${(childrenMap[n.id] || []).length === 0 ? 1 : 0}`);
        state.dpGroups.forEach(g => {
          if (state.display[g.name]) {
            const val = state.dpResults[n.id]?.[g.name];
            if (val !== undefined) parts.push(`${g.name}:${formatVal(val)}`);
          }
        });

        ctx.textAlign = 'center';
        if (state.display.id) {
          ctx.fillStyle = '#fff'; ctx.font = 'bold 12px JetBrains Mono, monospace';
          ctx.fillText(n.id, n.x, n.y - (parts.length > 0 ? 5 : 4));
        }
        if (parts.length > 0) {
          ctx.fillStyle = '#bd93f9'; ctx.font = '9px JetBrains Mono, monospace';
          ctx.fillText(parts.join(' | '), n.x, n.y + (state.display.id ? 10 : 4));
        }
      });
    }

    // =============================================
    // EVENT BINDING
    // =============================================
    function bindEvents() {
      window.addEventListener('resize', resize);

      window.addEventListener('keydown', e => {
        const active = document.activeElement.tagName;
        if (active === 'INPUT' || active === 'TEXTAREA' || active === 'SELECT') {
          if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') { e.preventDefault(); runDP(); }
          return;
        }
        if (['a', 'c', 's', 'Delete', 'Backspace'].includes(e.key)) e.preventDefault();
        if (e.key === 'a') setMode('add');
        if (e.key === 'c') setMode('connect');
        if (e.key === 's') setMode('select');
        if (e.key === 'Delete' || e.key === 'Backspace') deleteSelected();
        if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undo(); }
        if ((e.ctrlKey || e.metaKey) && e.key === 'y') { e.preventDefault(); redo(); }
      });

      document.getElementById('btnAdd').onclick = () => setMode('add');
      document.getElementById('btnConnect').onclick = () => setMode('connect');
      document.getElementById('btnSelect').onclick = () => setMode('select');

      document.getElementById('tglTreeContainer').onclick = () => toggle('isTree');
      document.getElementById('tglDirectedContainer').onclick = () => toggle('isDirected');
      document.getElementById('tglShowEdgeWContainer').onclick = () => toggle('showEdgeW');

      document.getElementById('btnUndo').onclick = undo;
      document.getElementById('btnRedo').onclick = redo;

      document.getElementById('btnOpenImport').onclick = () => document.getElementById('importModal').classList.add('active');
      document.getElementById('btnModalClose').onclick = () => document.getElementById('importModal').classList.remove('active');
      document.getElementById('btnModalImport').onclick = importData;
      document.getElementById('btnResetSave').onclick = resetStorage;

      document.getElementById('btnDelSel').onclick = deleteSelected;
      document.getElementById('btnRunDp').onclick = runDP;
      document.getElementById('btnSaveFormula').onclick = promptSaveFormula;
      document.getElementById('btnDeleteFormula').onclick = promptDeleteFormula;

      document.getElementById('btnCopy').onclick = () => {
        navigator.clipboard.writeText(document.getElementById('textOutput').textContent);
        const btn = document.getElementById('btnCopy');
        btn.textContent = 'Done'; setTimeout(() => btn.textContent = 'Copy', 1000);
      };

      const selWeightInput = document.getElementById('selWeight');
      selWeightInput.onchange = e => { updateSelectedWeight(e.target.value); saveHistory(); };
      selWeightInput.oninput = e => updateSelectedWeight(e.target.value);

      document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.onclick = () => {
          document.querySelectorAll('.tab-btn').forEach(t => t.classList.remove('active'));
          btn.classList.add('active');
          document.querySelectorAll('.tab-content').forEach(c => c.classList.toggle('hidden', c.id !== `tab-${btn.dataset.tab}`));
        };
      });

      displayContainer.onchange = e => {
        if (e.target.type === 'checkbox' && e.target.dataset.opt) {
          state.display[e.target.dataset.opt] = e.target.checked;
          render(); saveToStorage();
        }
      };

      document.getElementById('dpExamples').onchange = e => {
        const val = e.target.value;
        let code = null;
        
        // Check built-in examples
        if (val && EXAMPLES[val]) {
          code = EXAMPLES[val];
        }
        // Check custom formulas
        else if (val && val.startsWith('custom_')) {
          const customKey = val.substring(7); // Remove 'custom_' prefix
          if (customFormulas[customKey]) {
            code = customFormulas[customKey];
          }
        }
        
        if (code) {
          document.getElementById('dpCode').value = code;
          quickParseDpDefs(code);
          lastDpsLen = -1;
          updateDisplayOptions();
          saveToStorage();
        }
        e.target.value = '';
      };

      // Canvas mouse events
      canvas.onmousedown = ev => {
        const pos = { x: ev.offsetX, y: ev.offsetY };
        const node = findNode(pos);
        const edge = findEdge(pos);

        if (state.mode === 'add') {
          if (!node) addNode(pos.x, pos.y);
          else selectObj(node);
        } else if (state.mode === 'connect') {
          if (node) {
            if (!state.connectSource) state.connectSource = node;
            else { addEdge(state.connectSource, node); state.connectSource = null; }
          } else state.connectSource = null;
          render();
        } else {
          if (node) {
            state.dragging = { id: node.id, ox: pos.x - node.x, oy: pos.y - node.y };
            selectObj(node);
          } else if (edge) {
            selectEdge(edge);
          } else {
            state.selected = null;
            showSelInfo();
          }
          render();
        }
      };

      canvas.onmousemove = ev => {
        if (state.dragging) {
          const n = state.nodes.find(x => x.id === state.dragging.id);
          if (n) { n.x = ev.offsetX - state.dragging.ox; n.y = ev.offsetY - state.dragging.oy; render(); }
        }
      };

      const stopDrag = () => { if (state.dragging) saveHistory(); state.dragging = null; };
      canvas.onmouseup = stopDrag;
      canvas.onmouseleave = stopDrag;
    }

    // =============================================
    // INIT
    // =============================================
    function init() {
      canvas = document.getElementById('graphCanvas');
      ctx = canvas.getContext('2d');
      displayContainer = document.getElementById('displayOptionsContainer');

      document.getElementById('docsContent').innerHTML = buildDocs();

      loadCustomFormulas();
      loadFromStorage();
      updateDropdownWithCustomFormulas();
      resize();
      bindEvents();
      saveHistory();
      fullUpdate();
      setMode('add');

      if (!document.getElementById('dpCode').value) {
        document.getElementById('dpCode').value = EXAMPLES.subtree_sum;
        quickParseDpDefs(EXAMPLES.subtree_sum);
        updateDisplayOptions();
      }
    }

    init();
  </script>
</body>
</html>
